// Package tests provides end-to-end testing for the OAuth2 server.
// It tests the complete OAuth2 authorization flow including user authentication,
// authorization code generation, token exchange, and API access.
package tests

import (
	"bytes"
	"context"
	"crypto/rand"
	"crypto/rsa"
	"database/sql"
	"encoding/json"
	"fmt"
	"html/template"
	"net/http"
	"net/http/httptest"
	"net/url"
	"strconv"
	"strings"
	"testing"
	"time"

	"flash-oauth2/config"
	"flash-oauth2/database"
	"flash-oau	var response struct {
		Message   string             `json:"messag	var response struct {
	var response struct {
		Keys []*models.AppKeyPair `json:"keys"`
	}ss		var respo	// Test get developer apps
	t.Run("Get Developer Apps API", func(t *testing.T) {
		req, _ := http.NewRequest("GET", fmt.Sprintf("/api/admin/developers/%s/apps", developerID), nil)
		w := httptest.NewRecorder()
		ts.Router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusOK, w.Code)

		var response struct {
			Apps []*models.ExternalApp `json:"apps"`
		}
		err := json.Unmarshal(w.Body.Bytes(), &response)
		require.NoError(t, err)

		assert.GreaterOrEqual(t, len(response.Apps), 1)
	})ps []*models.ExternalApp `json:"apps"`
		}string               `json:"message"`
		KeyPair *models.AppKeyPair `json:"key_pair"`
	}		Developer *models.Developer `json:"developer"`
	}ha// RegisterTestExternalApp registers a test external application and returns the created app
func (ts *TestServer) RegisterTestExternalApp(t *testing.T, developerID string) *models.ExternalApp {
	registerData := map[string]interface{}{
		"developer_id":  developerID,
		"name":         "Test Mobile App",
		"description":  "Test mobile application for e2e testing",
		"callback_url": "https://app.example.com/callback",
		"scopes":       "openid profile read write",
	}"flash-oauth2/models"
	"flash-oauth2/routes"

	"github.com/gin-gonic/gin"
	"github.com/lib/pq"
	"github.com/redis/go-redis/v9"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestServer represents the test server instance
type TestServer struct {
	DB     *sql.DB
	Redis  *redis.Client
	Router *gin.Engine
	Config *config.Config
}

// TestClient represents a test OAuth2 client
type TestClient struct {
	ID           string
	Secret       string
	Name         string
	RedirectURIs []string
}

// TestUser represents a test user
type TestUser struct {
	ID    int
	Phone string
}

// SetupTestServer initializes a test server instance
// Returns nil if dependencies are not available (allows graceful test skipping)
func SetupTestServer(t *testing.T) *TestServer {
	// Set Gin to test mode
	gin.SetMode(gin.TestMode)

	// Load test configuration
	cfg := &config.Config{
		Port:        "8080",
		DatabaseURL: "postgres://postgres:1q2w3e4r@localhost:5432/oauth2_test?sslmode=disable",
		RedisURL:    "redis://localhost:6379/15", // Use database 15 for testing
	}

	// Generate RSA keys for testing
	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	require.NoError(t, err, "Failed to generate RSA keys")
	cfg.JWTPrivateKey = privateKey
	cfg.JWTPublicKey = &privateKey.PublicKey

	// Try to initialize database connection
	db, err := database.Init(cfg.DatabaseURL)
	if err != nil {
		t.Logf("Database not available: %v", err)
		return nil
	}

	// Initialize Redis connection
	redisClient, err := redis.ParseURL(cfg.RedisURL)
	if err != nil {
		t.Logf("Redis configuration error: %v", err)
		return nil
	}
	redisConn := redis.NewClient(redisClient)

	// Test Redis connection
	_, err = redisConn.Ping(context.Background()).Result()
	if err != nil {
		t.Logf("Redis not available: %v", err)
		return nil
	}

	// Run database migrations
	err = database.Migrate(db)
	require.NoError(t, err, "Failed to run database migrations")

	// Initialize handlers
	handler := handlers.New(db, redisConn, cfg)

	// Setup routes
	router := gin.New()

	// Add a simple HTML template for testing to avoid nil pointer errors
	router.SetHTMLTemplate(template.Must(template.New("").Parse(`
		{{define "login.html"}}
		<!DOCTYPE html>
		<html><head><title>Test Login</title></head>
		<body>
		<h1>OAuth2 Login</h1>
		<form method="post" action="/oauth/authorize">
			<input type="hidden" name="client_id" value="{{.client_id}}">
			<input type="hidden" name="redirect_uri" value="{{.redirect_uri}}">
			<input type="hidden" name="scope" value="{{.scope}}">
			<input type="hidden" name="state" value="{{.state}}">
			<input type="hidden" name="response_type" value="{{.response_type}}">
			<input type="text" name="phone" placeholder="Phone Number" required>
			<input type="text" name="code" placeholder="Verification Code" required>
			<button type="submit">Login</button>
		</form>
		</body></html>
		{{end}}
	`)))

	routes.Setup(router, handler)
	routes.SetupAppManagement(router, db, redisConn)

	return &TestServer{
		DB:     db,
		Redis:  redisConn,
		Router: router,
		Config: cfg,
	}
}

// TrySetupTestServer attempts to set up a test server
// Returns nil if setup fails (e.g., database not available)
func TrySetupTestServer(t *testing.T) *TestServer {
	// First check if database is available
	config := GetTestConfig()
	db, err := sql.Open("postgres", config.DatabaseURL)
	if err != nil {
		t.Logf("Cannot connect to database: %v", err)
		return nil
	}

	err = db.Ping()
	if err != nil {
		db.Close()
		t.Logf("Cannot ping database: %v", err)
		return nil
	}
	db.Close()

	// If database is available, try to set up test server
	ts := SetupTestServer(t)
	return ts
}

// TeardownTestServer cleans up test resources
func (ts *TestServer) TeardownTestServer(t *testing.T) {
	// Clean up test data
	ts.CleanupTestData(t)

	// Close connections
	if ts.DB != nil {
		ts.DB.Close()
	}
	if ts.Redis != nil {
		ts.Redis.Close()
	}
}

// CleanupTestData removes all test data from database and Redis
func (ts *TestServer) CleanupTestData(t *testing.T) {
	// Clear Redis database
	err := ts.Redis.FlushDB(context.Background()).Err()
	require.NoError(t, err, "Failed to flush Redis database")

	// Clear database tables
	tables := []string{"refresh_tokens", "access_tokens", "auth_codes", "users", "oauth_clients"}
	for _, table := range tables {
		_, err := ts.DB.Exec(fmt.Sprintf("DELETE FROM %s", table))
		require.NoError(t, err, "Failed to clear table: %s", table)
	}
}

// CreateTestClient creates a test OAuth2 client
func (ts *TestServer) CreateTestClient(t *testing.T) *TestClient {
	client := &TestClient{
		ID:           "test-client-id",
		Secret:       "test-client-secret",
		Name:         "Test Application",
		RedirectURIs: []string{"http://localhost:3000/callback", "https://app.example.com/callback"},
	}

	// Insert test client into database (with conflict handling)
	_, err := ts.DB.Exec(`
		INSERT INTO oauth_clients (id, secret, name, redirect_uris, grant_types, response_types, scope, created_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, CURRENT_TIMESTAMP)
		ON CONFLICT (id) DO UPDATE SET
			secret = EXCLUDED.secret,
			name = EXCLUDED.name,
			redirect_uris = EXCLUDED.redirect_uris,
			grant_types = EXCLUDED.grant_types,
			response_types = EXCLUDED.response_types,
			scope = EXCLUDED.scope
	`, client.ID, client.Secret, client.Name,
		pq.Array([]string{"http://localhost:3000/callback", "https://app.example.com/callback"}),
		pq.Array([]string{"authorization_code", "refresh_token"}),
		pq.Array([]string{"code"}),
		"openid profile")

	require.NoError(t, err, "Failed to create test client")
	return client
}

// CreateTestUser creates a test user
func (ts *TestServer) CreateTestUser(t *testing.T, phone string) *TestUser {
	var userID int
	err := ts.DB.QueryRow(`
		INSERT INTO users (phone, created_at, updated_at)
		VALUES ($1, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
		ON CONFLICT (phone) DO UPDATE SET updated_at = CURRENT_TIMESTAMP
		RETURNING id
	`, phone).Scan(&userID)

	require.NoError(t, err, "Failed to create test user")

	return &TestUser{
		ID:    userID,
		Phone: phone,
	}
}

// SendVerificationCode sends a verification code for the given phone number
func (ts *TestServer) SendVerificationCode(t *testing.T, phone string) string {
	requestBody := map[string]string{"phone": phone}
	jsonBody, _ := json.Marshal(requestBody)

	req := httptest.NewRequest("POST", "/send-code", bytes.NewBuffer(jsonBody))
	req.Header.Set("Content-Type", "application/json")

	w := httptest.NewRecorder()
	ts.Router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code, "Send verification code should succeed")

	// For testing, we'll generate a predictable code
	// In real implementation, this would be stored in Redis
	testCode := "123456"

	// Store the verification code in Redis for testing
	key := fmt.Sprintf("verification_code:%s", phone)
	err := ts.Redis.Set(context.Background(), key, testCode, 5*time.Minute).Err()
	require.NoError(t, err, "Failed to store verification code in Redis")

	return testCode
}

// LoginWithCode performs user login with phone and verification code
func (ts *TestServer) LoginWithCode(t *testing.T, phone, code string) {
	requestBody := map[string]string{
		"phone": phone,
		"code":  code,
	}
	jsonBody, _ := json.Marshal(requestBody)

	req := httptest.NewRequest("POST", "/login", bytes.NewBuffer(jsonBody))
	req.Header.Set("Content-Type", "application/json")

	w := httptest.NewRecorder()
	ts.Router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code, "Login should succeed")
}

// GetAuthorizationCode initiates OAuth2 flow and returns authorization code
func (ts *TestServer) GetAuthorizationCode(t *testing.T, client *TestClient, redirectURI, scope, state string) string {
	// Build authorization URL
	params := url.Values{}
	params.Add("client_id", client.ID)
	params.Add("redirect_uri", redirectURI)
	params.Add("response_type", "code")
	params.Add("scope", scope)
	if state != "" {
		params.Add("state", state)
	}

	authURL := "/authorize?" + params.Encode()

	req := httptest.NewRequest("GET", authURL, nil)
	w := httptest.NewRecorder()
	ts.Router.ServeHTTP(w, req)

	// Should redirect to login page initially
	assert.Equal(t, http.StatusOK, w.Code, "Should show login page")

	// For testing purposes, we'll create an authorization code directly
	// In real flow, user would login and then get redirected with the code

	// Create a test user and simulate successful login
	user := ts.CreateTestUser(t, "13800138000")

	// Create authorization code directly in database
	authCode := "test-auth-code-" + strconv.FormatInt(time.Now().UnixNano(), 36)
	expiresAt := time.Now().Add(10 * time.Minute)

	_, err := ts.DB.Exec(`
		INSERT INTO auth_codes (code, client_id, user_id, redirect_uri, scope, expires_at, created_at)
		VALUES ($1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP)
	`, authCode, client.ID, user.ID, redirectURI, scope, expiresAt)

	require.NoError(t, err, "Failed to create authorization code")

	return authCode
}

// ExchangeCodeForTokens exchanges authorization code for access tokens
func (ts *TestServer) ExchangeCodeForTokens(t *testing.T, client *TestClient, code, redirectURI string) map[string]interface{} {
	// Prepare token request
	data := url.Values{}
	data.Set("grant_type", "authorization_code")
	data.Set("code", code)
	data.Set("client_id", client.ID)
	data.Set("client_secret", client.Secret)
	data.Set("redirect_uri", redirectURI)

	req := httptest.NewRequest("POST", "/token", strings.NewReader(data.Encode()))
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	w := httptest.NewRecorder()
	ts.Router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code, "Token exchange should succeed")

	// Parse response
	var tokenResponse map[string]interface{}
	err := json.Unmarshal(w.Body.Bytes(), &tokenResponse)
	require.NoError(t, err, "Failed to parse token response")

	// Verify required fields
	assert.Contains(t, tokenResponse, "access_token", "Response should contain access_token")
	assert.Contains(t, tokenResponse, "token_type", "Response should contain token_type")
	assert.Contains(t, tokenResponse, "expires_in", "Response should contain expires_in")
	assert.Equal(t, "Bearer", tokenResponse["token_type"], "Token type should be Bearer")

	return tokenResponse
}

// GetUserInfo retrieves user information using access token
func (ts *TestServer) GetUserInfo(t *testing.T, accessToken string) map[string]interface{} {
	req := httptest.NewRequest("GET", "/userinfo", nil)
	req.Header.Set("Authorization", "Bearer "+accessToken)

	w := httptest.NewRecorder()
	ts.Router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code, "UserInfo request should succeed")

	// Parse response
	var userInfo map[string]interface{}
	err := json.Unmarshal(w.Body.Bytes(), &userInfo)
	require.NoError(t, err, "Failed to parse user info response")

	return userInfo
}

// RefreshTokens refreshes access token using refresh token
func (ts *TestServer) RefreshTokens(t *testing.T, client *TestClient, refreshToken string) map[string]interface{} {
	data := url.Values{}
	data.Set("grant_type", "refresh_token")
	data.Set("refresh_token", refreshToken)
	data.Set("client_id", client.ID)
	data.Set("client_secret", client.Secret)

	req := httptest.NewRequest("POST", "/token", strings.NewReader(data.Encode()))
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	w := httptest.NewRecorder()
	ts.Router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code, "Token refresh should succeed")

	// Parse response
	var tokenResponse map[string]interface{}
	err := json.Unmarshal(w.Body.Bytes(), &tokenResponse)
	require.NoError(t, err, "Failed to parse token refresh response")

	return tokenResponse
}

// IntrospectToken introspects access token
func (ts *TestServer) IntrospectToken(t *testing.T, client *TestClient, token string) map[string]interface{} {
	data := url.Values{}
	data.Set("token", token)
	data.Set("client_id", client.ID)
	data.Set("client_secret", client.Secret)

	req := httptest.NewRequest("POST", "/introspect", strings.NewReader(data.Encode()))
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	w := httptest.NewRecorder()
	ts.Router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code, "Token introspection should succeed")

	// Parse response
	var introspectionResponse map[string]interface{}
	err := json.Unmarshal(w.Body.Bytes(), &introspectionResponse)
	require.NoError(t, err, "Failed to parse introspection response")

	return introspectionResponse
}

// GetJWKS retrieves JSON Web Key Set
func (ts *TestServer) GetJWKS(t *testing.T) map[string]interface{} {
	req := httptest.NewRequest("GET", "/.well-known/jwks.json", nil)
	w := httptest.NewRecorder()
	ts.Router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code, "JWKS request should succeed")

	// Parse response
	var jwks map[string]interface{}
	err := json.Unmarshal(w.Body.Bytes(), &jwks)
	require.NoError(t, err, "Failed to parse JWKS response")

	return jwks
}

// CheckHealthEndpoint tests the health check endpoint
func (ts *TestServer) CheckHealthEndpoint(t *testing.T) {
	req := httptest.NewRequest("GET", "/health", nil)
	w := httptest.NewRecorder()
	ts.Router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code, "Health check should succeed")

	var response map[string]interface{}
	err := json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err, "Failed to parse health response")

	assert.Equal(t, "ok", response["status"], "Health status should be ok")
}

// GetDocumentation tests the documentation endpoint
func (ts *TestServer) GetDocumentation(t *testing.T) {
	req := httptest.NewRequest("GET", "/docs", nil)
	w := httptest.NewRecorder()
	ts.Router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code, "Documentation request should succeed")
	assert.Contains(t, w.Header().Get("Content-Type"), "text/html", "Documentation should return HTML")
	assert.Contains(t, w.Body.String(), "Flash OAuth2 Server", "Documentation should contain title")
}

// Application Management Test Helper Methods

// RegisterTestDeveloper registers a test developer and returns the created developer
func (ts *TestServer) RegisterTestDeveloper(t *testing.T) *models.Developer {
	registerData := map[string]interface{}{
		"name":        "Test Company",
		"email":       "test@company.com",
		"phone":       "+86-138-0013-8000",
		"description": "Test company for e2e testing",
	}

	jsonData, err := json.Marshal(registerData)
	require.NoError(t, err)

	req, _ := http.NewRequest("POST", "/api/admin/developers", bytes.NewBuffer(jsonData))
	req.Header.Set("Content-Type", "application/json")

	w := httptest.NewRecorder()
	ts.Router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusCreated, w.Code, "Developer registration should succeed")

	var response struct {
		Success   bool              `json:"success"`
		Developer *models.Developer `json:"developer"`
	}
	err = json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err, "Failed to parse developer registration response")

	assert.NotEmpty(t, response.Message)
	assert.NotNil(t, response.Developer)

	return response.Developer
}

// RegisterTestExternalApp registers a test external application and returns the created app
func (ts *TestServer) RegisterTestExternalApp(t *testing.T, developerID string) *models.ExternalApp {
	registerData := map[string]interface{}{
		"developer_id":  developerID,
		"name":         "Test Mobile App",
		"description":  "Test mobile application for e2e testing",
		"callback_url": "https://app.example.com/callback",
		"scopes":       "openid profile read write",
	}

	jsonData, err := json.Marshal(registerData)
	require.NoError(t, err)

	req, _ := http.NewRequest("POST", "/api/admin/apps", bytes.NewBuffer(jsonData))
	req.Header.Set("Content-Type", "application/json")

	w := httptest.NewRecorder()
	ts.Router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusCreated, w.Code, "External app registration should succeed")

	var response struct {
		Message string              `json:"message"`
		App     *models.ExternalApp `json:"app"`
	}
	err = json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err, "Failed to parse app registration response")

	assert.NotEmpty(t, response.Message)
	assert.NotNil(t, response.App)

	return response.App
}

// GenerateTestKeyPair generates a test key pair for an application and returns the created key pair
func (ts *TestServer) GenerateTestKeyPair(t *testing.T, appID string) *models.AppKeyPair {
	generateData := map[string]interface{}{
		"expires_at": "2025-12-31T23:59:59Z",
	}

	jsonData, err := json.Marshal(generateData)
	require.NoError(t, err)

	req, _ := http.NewRequest("POST", fmt.Sprintf("/api/admin/apps/%s/keys", appID), bytes.NewBuffer(jsonData))
	req.Header.Set("Content-Type", "application/json")

	w := httptest.NewRecorder()
	ts.Router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusCreated, w.Code, "Key pair generation should succeed")

	var response struct {
		Success bool               `json:"success"`
		KeyPair *models.AppKeyPair `json:"key_pair"`
	}
	err = json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err, "Failed to parse key generation response")

	assert.NotEmpty(t, response.Message)
	assert.NotNil(t, response.KeyPair)

	return response.KeyPair
}

// GetAppWithKeys retrieves an application with its keys
func (ts *TestServer) GetAppWithKeys(t *testing.T, appID string) []*models.AppKeyPair {
	req, _ := http.NewRequest("GET", fmt.Sprintf("/api/admin/apps/%s/keys", appID), nil)
	w := httptest.NewRecorder()
	ts.Router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code, "Getting app keys should succeed")

	var response struct {
		Success bool                 `json:"success"`
		Keys    []*models.AppKeyPair `json:"keys"`
	}
	err := json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err, "Failed to parse app keys response")

	return response.Keys
}

// RevokeTestKey revokes a test key
func (ts *TestServer) RevokeTestKey(t *testing.T, keyID string) {
	req, _ := http.NewRequest("POST", fmt.Sprintf("/api/admin/keys/%s/revoke", keyID), nil)
	w := httptest.NewRecorder()
	ts.Router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code, "Key revocation should succeed")

	var response struct {
		Message string `json:"message"`
	}
	err := json.Unmarshal(w.Body.Bytes(), &response)
	require.NoError(t, err, "Failed to parse key revocation response")

	assert.NotEmpty(t, response.Message)
}

// TestManagementDashboard tests the management dashboard page
func (ts *TestServer) TestManagementDashboard(t *testing.T) {
	req, _ := http.NewRequest("GET", "/admin/dashboard", nil)
	w := httptest.NewRecorder()
	ts.Router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code, "Dashboard should load successfully")
	assert.Contains(t, w.Header().Get("Content-Type"), "text/html", "Dashboard should return HTML")

	body := w.Body.String()
	assert.Contains(t, body, "应用管理平台", "Dashboard should contain platform title")
	assert.Contains(t, body, "注册应用数量", "Dashboard should contain app count")
	assert.Contains(t, body, "活跃密钥数量", "Dashboard should contain key count")
}

// TestAppDetailsPage tests the application details page
func (ts *TestServer) TestAppDetailsPage(t *testing.T, appID string) {
	req, _ := http.NewRequest("GET", fmt.Sprintf("/admin/apps/%s", appID), nil)
	w := httptest.NewRecorder()
	ts.Router.ServeHTTP(w, req)

	assert.Equal(t, http.StatusOK, w.Code, "App details page should load successfully")
	assert.Contains(t, w.Header().Get("Content-Type"), "text/html", "App details should return HTML")

	body := w.Body.String()
	assert.Contains(t, body, "应用详情", "App details should contain page title")
	assert.Contains(t, body, "密钥管理", "App details should contain key management section")
	assert.Contains(t, body, "生成新密钥", "App details should contain generate key button")
}

// TestAppManagementAPI tests the app management API endpoints
func (ts *TestServer) TestAppManagementAPI(t *testing.T, developerID, appID string) {
	// Test get all apps
	t.Run("Get All Apps API", func(t *testing.T) {
		req, _ := http.NewRequest("GET", "/api/admin/apps", nil)
		w := httptest.NewRecorder()
		ts.Router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusOK, w.Code)

		var response struct {
			Apps []*models.ExternalApp `json:"apps"`
		}
		err := json.Unmarshal(w.Body.Bytes(), &response)
		require.NoError(t, err)

		assert.GreaterOrEqual(t, len(response.Apps), 1)
	})

	// Test get developer apps
	t.Run("Get Developer Apps API", func(t *testing.T) {
		req, _ := http.NewRequest("GET", fmt.Sprintf("/api/admin/developers/%s/apps", developerID), nil)
		w := httptest.NewRecorder()
		ts.Router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusOK, w.Code)

		var response struct {
			Success bool                  `json:"success"`
			Apps    []*models.ExternalApp `json:"apps"`
		}
		err := json.Unmarshal(w.Body.Bytes(), &response)
		require.NoError(t, err)

		assert.True(t, response.Success)
		assert.GreaterOrEqual(t, len(response.Apps), 1)
	})
}
